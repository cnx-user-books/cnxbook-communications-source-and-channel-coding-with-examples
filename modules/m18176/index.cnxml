<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Convolutional FECC Encoder</title>
  <metadata>
  <md:content-id>m18176</md:content-id><md:title>Convolutional FECC Encoder</md:title>
  <md:abstract>Convolutional codes form part of forward error correcting coders (FECC).  They are non-systematic and are generated by passing a data sequence through a transversal or finite impulse response (FIR) filter.  This module provides an example of encoding data with a simple convolutional encoder.</md:abstract>
  <md:uuid>40320cff-55a3-490a-987f-f1fe13003b98</md:uuid>
</metadata>
  <content>
    <section id="id7000584">
      <title>FECC – ½ Rate Convolutional Encoder Example</title>
      <section id="id5101551">
       <title>Convolutional coding</title>
 
      <para id="id6666824">Convolutional codes are another type of forward error correcting coder (FECC) which are quite distinct from block codes. They are simpler to implement for longer codes than block coders and soft decision decoding can be employed easily at the decoder. </para>
      <para id="id5822790">Convolutional codes are non-systematic (i.e. the transmitted data bits do not appear directly in the output encoded data stream) and are generated by passing a data sequence through a transversal or finite impulse response (FIR) filter. The coder output can be regarded as the convolution of the input sequence with the impulse response of the coder, hence their name: convolutional codes. </para>
</section>
      <section id="id7000214">
<title>Convolutional encoder </title>
      <para id="id7013729">A simple example is shown in <link target-id="id6519753"/>. Here the encoder shift register starts with zeros at all three stored locations (i.e. 0, 0, 0). The input data sequence to be encoded is 1, 1, 0, 1 in this example. The shift register contents thus become, after each data bit arrives and propagates into the shift register: 100, 110, 011, 101. As there are two outputs for overy input bit the above encoder is rate ½. </para>
      <para id="id6406228">The first output is obtained after arrival of a new data bit into the shift register when the switch is in the upper position, the second with the switch in the lower position. Thus, in this example, the switch will generate, through the exclusive OR gates, from the four input data bits: 1, 1, 0, 1, the corresponding four output digit pairs: 11, 10, 11, 01</para>
      <figure id="id6519753"><media id="id1167613514622" alt=""><image src="../../media/fig1-235b.png" mime-type="image/png"/></media><caption>½ rate convolutional encoder</caption></figure>
      <para id="id7003284">This particular encoder has 3 stages in “the filter” and therefore we say that the constraint length n = 3. The very latest encoders available commercially typically have constraint lengths up to n = 9. </para>

     <para id="id6867038">We can consider the coder outputs from the exclusive OR gates as being generated by two polynomials:</para>

<equation id="eqn1">
       <m:math>
        <m:apply><m:eq/>
           
            <m:apply>
            <m:times/>
              <m:ci>
                <m:msub>
                   <m:ci>P</m:ci>
                   <m:cn>1</m:cn>
                </m:msub>
               </m:ci>
                <m:ci>(x)</m:ci>
           </m:apply>

           <m:apply><m:plus/>
             <m:cn>1</m:cn>
              <m:ci>
                <m:msup>
                   <m:ci>x</m:ci>
                   <m:cn>2</m:cn>
                </m:msup>
              </m:ci>
           </m:apply>
         </m:apply>
        </m:math>
        </equation> 



<equation id="eqn2">
       <m:math>
        <m:apply><m:eq/>
           
            <m:apply>
            <m:times/>
              <m:ci>
                <m:msub>
                   <m:ci>P</m:ci>
                   <m:cn>2</m:cn>
                </m:msub>
               </m:ci>
                <m:ci>(x)</m:ci>
           </m:apply>

           <m:apply><m:plus/>
             <m:cn>1</m:cn>
                   <m:ci>x</m:ci>
           </m:apply>
         </m:apply>
        </m:math>
        </equation> 

<para id="element-511">These are often expressed in octal notation, in our example: </para>



<equation id="eqn3">
       <m:math>
        <m:apply><m:eq/>
           
            <m:apply>
              <m:ci>
                <m:msub>
                   <m:ci>P</m:ci>
                   <m:cn>1</m:cn>
                </m:msub>
               </m:ci>
           </m:apply>

           <m:apply>
             <m:times/>
              <m:ci>
                <m:msub>
                   <m:cn>5</m:cn>
                   <m:ci>o</m:ci>
                </m:msub>
              </m:ci>
             <m:cn>(101)</m:cn>   
           </m:apply>
         </m:apply>
        </m:math>
        </equation> 



<equation id="eqn4">
       <m:math>
        <m:apply><m:eq/>
           
            <m:apply>
              <m:ci>
                <m:msub>
                   <m:ci>P</m:ci>
                   <m:cn>2</m:cn>
                </m:msub>
               </m:ci>
           </m:apply>

           <m:apply>
             <m:times/>
              <m:ci>
                <m:msub>
                   <m:cn>6</m:cn>
                   <m:ci>o</m:ci>
                </m:msub>
              </m:ci>
             <m:cn>(110)</m:cn>   
           </m:apply>
         </m:apply>
        </m:math>
        </equation> 


      <para id="id6830390">This encoder may also be regarded as a state machine. The next state is determined by the next input bit or value combined with the previous two input bits or values which were stored in the shift register, (i.e. the previous state). </para>
</section>
      <section id="id6814707">
<title>Tree state diagram </title>
      <para id="id4438853">We can regard this as a Mealy state machine with four states corresponding to all the possible combinations of the first two stages in the shift register. </para>
      <para id="id7031910">The tree diagram for this state machine is now shown in <link target-id="id7003522"/>, again starting from the all zeros state or condition. The encoder starts in state A holding two zeros (00) within the first two stages of the shift register. (We ignore the final stored digit as it is lost when a new data bit propagates into the shift register.) If the next input bit is a zero (0) we follow the upper path to state B where the stored data is updated to 00. If the next input bit is a one (1) we follow the lower path to progress to the corresponding state C where the stored data is now 10. </para>
      <para id="id4438888">The convention is to enter the updated new stored state values below the state letter (B/C). Now returning to <link target-id="id6519753"/> and the exclusive OR gate connections one can derive the output data bits generated within the encoder. For state B these are 00 and for state C these are 11. These outputs are entered alongside the state in <link target-id="id7003522"/>. States B/C correspond to the arrival of the first new data bit to be encoded, while D/E/F/G correspond to the second data bit and H/I/J/K/h/i/j/k the third data bit.</para>
      <figure id="id7003522"><media id="id1167609761940" alt=""><image src="../../media/fig2-e35f.png" mime-type="image/png"/></media><caption>Encoded data tree diagram for the encoder of Figure 1</caption></figure>


      <para id="id3715106">The tree diagram in <link target-id="id7003522"/> tends to suggest that there are eight states in the last layer of the tree and that this will continue to grow. However some states in the last layer (i.e. the stored data in the encoder) are equivalent as indicated by the same letter on the tree (for example H and h). </para>
      <para id="id6692537">These pairs of states may be assumed to be equivalent because they have the same internal state for the first two stages of the shift register and therefore will behave exactly the same way to the receipt of a new (0 or 1) input data bit. </para>
</section>
   

      <section id="id6805729">
<title>Trellis state diagram</title>
      <para id="id4438999">Thus the tree can be folded into a trellis, as shown in , which is derived from the tree diagram of <link target-id="id7003522"/> and <link target-id="id6519753"/> encoder.  As the constraint length is n = 3 we have <m:math>
              <m:ci> 
                <m:msup> 
                   <m:cn>2</m:cn> 
                   <m:cn>(3-1)</m:cn> 
                </m:msup> 
              </m:ci> 
        </m:math>
 = 4 unique states: 00, 01, 10, 11 in <link target-id="id7003522"/>.  In <link target-id="id7001603"/> the states are shown as 00x to denote the third bit, x, which is lost or discarded following the arrival of a new data bit.</para>
 
   <figure id="id7001603"><media id="id1167610841356" alt=""><image src="../../media/trellis.png" mime-type="image/png"/></media><caption>Trellis Diagram corresponding to the Tree Diagram of Figure 2</caption></figure>


     <para id="id6814554">Note in <link target-id="id7001603"/> the horozontal arrangement of states A, B, D, H and L. The same applies to states C, E, I and M etc. The horizontal direction corresponds to time (the whole diagram in <link target-id="id7001603"/> now corresponds to encoding 4 input data bits). Here we have dropped the state information from <link target-id="id7003522"/> as the same states are all represented at the same horizontal level in <link target-id="id7001603"/>. The vertical direction here corresponds to the stored state values a, b, c, d in the encoder shift register.</para>
      <para id="id5824743">States along the time axis are thus equivalent, for example H is equivalent to L and C is equivalent to E etc. In fact all the states in a horizontal line are equivalent. Thus we can identify only four states in this coder: a, b, c and d and the related shift register stored values 00, 10, 01, 11 are shown in the left hand side of <link target-id="id7001603"/>. </para>
      <para id="id7007120">From any point, e.g. E, if the next input bit is a zero (0) we follow the upper path to state J where the stored data is updated to 01 and the output will be 01. If the next input bit is a one (1) we follow the lower path from E to progress to the next state K where the stored data is now 11 and the output will be 10 as indicated alongside the trellis path.</para>
</section>
      <section id="id5716495">
<title>Transition state diagram</title>
      <para id="id6805461">We can draw, if desired, the trellis diagram of <link target-id="id7001603"/> in <link target-id="id6667336"/> as a state diagram containing only these states with all the corresponding new data bits to be encoded and the corresponding two output bits generated per new input data bit (e.g. 1(10))</para>
      <figure id="id6667336"><media id="id1167608787735" alt=""><image src="../../media/fig4-68f1.png" mime-type="image/png"/></media><caption>State diagram corresponding to the encoder trellis diagram of Figure 3</caption></figure><note id="id1167610697943">This module has been created from lecture notes originated by P M Grant and D G M Cruickshank which are published in I A Glover and P M Grant, "Digital Communications", Pearson Education, 2009, ISBN 978-0-273-71830-7.  Powerpoint slides plus end of chapter problem examples/solutions are available for instructor use via password access at http://www.see.ed.ac.uk/~pmg/DIGICOMMS/</note>
</section>
    </section>
  </content>
</document>